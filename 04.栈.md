## 栈的基础
栈里面的元素遵循先进的后出，也就是First Input Last Out(FILO)
函数调用栈
递归为什么会导致栈溢出，就是因为是函数调用函数自己，如果没有合适的终止条件，就会导致栈溢出。
栈底
栈顶
出栈
入栈

## 栈结构的实现
### 1. 基于数组实现
JS自带了高度封装的数组结构，我们只需要调用数组的API即可对数组完成增删改查，JAVA中的数组是不能动态扩容的，必须在一开始创建一个数组结构的时候就明确这个数组存放的是什么类型的元素以及存放的元素数量，如果要往数组中添加元素，那么需要进行扩容操作。就是创建一个更大空间的数组，然后将原来的数组拷贝一份过去，然后将新的元素添加到数组末尾。
数组这种数据结构天然的缺点就是往头部或者中间插入一个元素的时候，插入位置后面的元素需要每个都往后移动一位，所以是比较消耗性能的
但是数组最大的优点是可以基于数字索引快速的对数组中元素进行访问。

### 2.基于链表实现


## 十进制转二进制的逻辑
100/2 = 50 0
50/2 = 25 0
25/2 = 12 1
12/2 = 6 0
6/2 = 3 0
3/2 = 1 1
1/2 = 0 1

100100

1/2 = 0 0



DEC 10进制 Decimal
BIN 2进制 Binary
HEX 16进制 Hexadecimal
OCT 8进制 Octal

十进制转二进制 最后得到的余数才是二进制最开始的数字
和栈的关系
每一次得到的余数 压入到栈顶
全部计算完成之后
此时栈顶的就是最后一次计算的余数
然后将数字从栈顶依次取出即可

1
0
0
1
0
0
[0,0,1,0,0,1]





1. 第一步先递归的求num的余数，将得到的余数依次push到栈中
2. 递归终止条件：当商等于0，那么就终止
```js
function dec2Bin(num){
	let yushu;
	let shang;
	let stack = new Stack();
	while(num > 2){
		yushu = num % 2
		shang = num / 2;
		num =shang;
		stack.push(yushu);
	}
	
	let res;
	for(let i=stack.size-1;i>=0;i--){
		res += stack[i]
	}
	console.log('res',res)
	return res;
}

```


原生JS中对于数字进制的转化提供了下面两个API：
1. ParseInt(str,redix) 将一个字符串str当做redix进制的数字，解析为10进制的数字。
关键字：字符串是几进制你说了算，但是结果一定是10进制的数字，因为这是一个Number类的方法，返回的一定是数字
用途:将一个有效数字字符串从N进制转化为10进制
注意：redix的范围是2-36 超出直接返回NaN

2. Number.prototype.toString(redix) 将一个十进制的数字num转化为redix进制的数字，然后将数字转化为字符串返回，这是数字和字符串的转化。
关键字：一定是10进制的数字去调这个方法，然后返回指定进制的数字的字符串表达，如果不传递那就默认是10进制
用途：将一个有效10进制数字从10进制转化为N进制
注意:redix的范围是2-36 超出抛出一个RangeError



## 十进制转N进制的逻辑