## 一、什么是哈希表？
首先几乎所有的编程语言都直接或间接的应用了哈希表这种数据结构，一般来说哈希表是基于数组来实现的，这里我们又要说下数组这种数据结构的缺点了。

### 数组的缺陷
数组进行查询操作的时候，会分为两种情况：
1. 如果是基于数字索引查询元素，那么查询效率非常高
2. 如果是基于内容也就是字符串查询元素，比如查询一个数组中name=lilei的那个对象，此时就需要先从头遍历数组来进行查询，其实查询效率低
数组开头插入元素和中间插入元素都会引起数组其他元素的位移，所以操作效率也不高；同样的数组删除元素的效率也不高，因为会引起数组其他元素的位移

### 哈希表的优势
哈希表基于数组实现，但是相对于数组又有很多优点：
1. 对于元素的插入、删除和新增都可以进行快速高效的操作
2. 无论有多少数据，插入和删除一个元素的时间都接近于一个常量即O(1)的时间复杂度
3. 哈希表的查询速度比树结构还要快，并且编码难度要比树结构低

### 哈希表的缺点
哈希表相对于数组也有一定的缺陷，主要还是集中在无序和去重两点，优点类似于集合的特点：
1. 哈希表中的数据是无序的，所以无法通过一种固定的顺序比如从小到大来进行遍历
2. 哈希表中的key是不可以重复的，也就是不能放置相同的key，用于保存不同的value

综上所述，哈希表结构就是数组，但是它神奇的地方在于对于数组的下标值的一种变换，通过哈希函数可以将字符串转化为数字下标。

## 二、哈希表的案例
### 案例1：保存所有员工信息
1. 通过数组来保存所有员工信息，必须要使用工号来当做数字索引。但是缺点是插入和删除员工消耗性能。
2. 通过链表来保存，缺点很明显，每次查询都需要从头遍历到尾部
3. 通过哈希表保存，通过员工的姓名设计一种哈希算法转化为数字索引，然后通过数字索引来操作。

### 案例2：保存联系人和电话
数组，不行，查找效率不高，因为数组的索引不可以是一个联系人名字或者一个电话号码
链表，也不行，每次查找都需要从头遍历到尾部
通过哈希函数，可以通过联系人姓名这个key直接获取到对应的下标值，然后拿到下标值直接获取到对应的信息
其实这个将姓名这种字符串转化为数组下标值的实现就是哈希函数

### 案例3：保存50000个单词信息，通过单词找到对应的读音、翻译等
存储50000个单词信息还是一样的道理，需要通过哈希函数将单词转化为对应的数组下标，这样就可以实现快速的操作。

## 三、将字母转化为数字的方案
以上所有的问题，其实都是将单词或者字符串要转化为数组下标值的问题，其实说白了就是字母/文字 转化为 数字：
+ 通过姓名转化为数字
+ 通过联系人姓名转化为数字
+ 通过单词转化为数字

现在主要的问题在于将字母该如何转化为数字呢？
现有的一个可以将单个英文字母a-z转化为数字的方案就是ASCII码，规定字母a代表数字97，字母z代表数字122，当然我们可以设计一个自己的编码系统那就是a-z依次代表数字1-26.但是这只是单个字母的转化，如果是多个字母拼接的单词该如何转化为数字呢？

### 单词转数字方案一：相加求和
最简单的方法就是将每个单词中的每一个字母的编码值依次相加求和，这个和就是最终转化后的数字。
比如cats单词转化为：3+1+19+20 = 43，但是这种方案的缺点太明显了，因为很有可能多个单词的和都是同一个数字，但是数组的同一个下标值只能存储一个元素，后来的数据就会覆盖前面的数据，所以这种方案是不合理的


### 单词转数字方案二：幂的连乘
还有一种方案就是将单词的每一个字母代表的数字进行幂的连乘。
比如一个数字9876用幂的连乘表示就是：9*10^3 + 8*10^2 + 7*10^1 + 6*10^0 = 9000 + 800 + 70 + 6 = 9876
同样的假设单词cats用幂的连乘表示如下：3*27^3 + 1*27^2 + 19*27^1 + 20*27^0 = 60337

这样通过幂的连乘得到的数字基本可以保证该单词转化为数字的唯一性，绝大多数情况下不会和其他单词重复，但这种方案同样有一个问题：
那就是如果一个单词是zzzzzzzzzz，此时这个单词通过幂的连乘之后得到的数字是一个很大的数字，首先创建一个这么大的数组很有可能内存不够，其次就算创建出来了，也有很多空位是无法被利用到的，因为现在我们只需要创建一个50000个单词的哈希表。

综合上面两种方案：
1. 第一种方案创建出来的数字下标太少而且容易重复
2. 第二种方案创建出来的数字下标太多造成浪费

## 四、认识哈希化
现在我们需要有一种压缩的办法，将幂的连乘得到的一个巨大的整数范围压缩到可接收的数组范围中，比如我们想要一个存放50000个单词的数组，那么一般情况下应该创建出来一个2倍大小也就是100000长度大小的数组，因为我们不能保证每一个数字下标都会对应到一个单词，所以一般情况下采取2倍大小的数组空间。

比如现在单词zzzzzzzzzzzzzzzzz通过幂的连乘之后得到的数字超过7000000000000000，我们现在的任务就是将0-7000000000000000这么大的一个范围压缩到0-100000这个范围大小。一般情况下我们采取取余操作来实现，比如我们将一个0-199的数字压缩到0-9的数字，其中的原理就是一个数被10整除之后余数一定在0-9之间，过程如下：
压缩前的数字是：[15,188,150,66，176]
15 % 10 = 5
188 % 10 = 8
150 % 10 = 0
66 % 10 = 6
176 % 10 = 6
压缩后的结果就是:[5,8,0,6,6]
当前压缩过后还是会有重复的数字下标比如6出现，但是重复的数量明显变小了，就算真的重复了我们也有办法解决。

## 五、解决哈希之后的数字冲突的方案
前面我们通过几个步骤依次解决了将单词转化为数字的几个问题：
1. 首先单词转化为数字我们采用了相对不容易重复的幂的连乘的方法来实现，但是产生了问题就是这样子产生的数组下标的值可能太大了，实际上我们只需要存储50000个单词用一个100000长度大小的数组就足够了，下标值过大会产生很多无效的数组下标;
2. 然后为了解决数组下标的范围太大的问题，我们采用了取余操作符来进行范围的压缩，将0-700000000000范围大数字都压缩到范围为0-100000范围中，但是就算我们采用了很好的哈希函数依然有可能发生冲突，那就是两个单词先转化为数字然后取余压缩之后的值相等，这种冲突是无法避免的，所以我们只能解决冲突。

一般情况下解决冲突的方法有2种，分别是：
1. 链地址法
2. 开放地址法

### 链地址法（数组的每一个位置存放的不是一个单独的元素，而是一个存放多个元素的数组）
链地址法解决冲突的方法是假设单词a和单词b转化之后的下标值相等假设都是100，那么原本下标为100的地方只应该存储一个元素，现在由于产生了冲突，变成了下标为100的地方存储一个数组或者链表，这个数组/链表中依次存储相同下标的元素，一旦有了新的单词c的下标也是100，那么就将c插入到这个数组的头部或者尾部。当在哈希表中查询的时候，先通过共同的下标100找到这个数组，然后再从这个数组中找想要的元素。

一般情况下，当冲突的元素要插入到前面的时候，此时最好用链表；否则一般情况下用数组就可以，因为都是线性查找，效率不会有多大差异。

### 开放地址法
开放地址法的主要原理就是寻找空白的单元格来添加冲突的元素，核心是寻找空白的单元格，寻找这个位置的方式有三种：
比如现在有一个长度为10的数组[0, ,22,13, ,85, ,77,28,99]

#### 1. 线性探测
+ 插入冲突的元素
比如现在我们要将一个冲突的元素32插入到这个数组中，32取余之后还是2，但是数组下标为2的位置上已经有了22，那么这个32该放在那个位置呢？
如果我们使用线性探测的方案，其实说白了就是步长为1，一个一个的探索空位然后将冲突元素放进去。具体来说这个数组的下标为4和6的地方还没有元素，首先探索到3的位置发现有值13，接着探索到4的位置发现没有值，那么就将32放到下标为4的这个单元格里。

+ 查询元素
当我们查询32的时候，我们先找到下标为2的地方看元素的值是否和32相等，这里查询出来元素的值为22，不相等此时就需要继续线性查找。找到下标为4的地方发现值为32，此时就将这个结果返回。

+ 查询为空时停止查询
还有一个问题就是如果32的位置之前没有插入过，也就是该数组中根本没有32，此时有一个原则就是只要查询的过程中发现某个位置是空位置，此时查询就要停止，然后将结果返回。因为在插入32的时候不可能跳过空的位置插入，只要有空的单元格就插入了。

+ 删除冲突的元素
当我们删除32的时候一般需要先找到32这个元素，然后将32对应的下标位置的值修改为-1.
注意这里不能写一个null，因为写成null的时候当查询其他元素的时候遇到空就直接停止了，后面其实是有要查询的元素的但是由于遇空就停止的原则，导致查询不到。

+ 线性探测的缺点：聚集
比如现在有一个空数组，我们插入的元素依次为20-21-22-23-24-25这种连续的元素，接下来当我们插入一个值为32的时候，由于下标值为2的地方已经有22存在了，那么此时使用线性探测的方案就需要连续跳过23-24-25多个元素才可以找到一个空位，将32插入到数组中。

上述这种一连串填充的单元就叫做聚集，聚集会影响哈希表的性能，因为无论是查询、删除还是插入都会发现连续的单元格都不允许我们存放新的元素，要寻找一个空白单元格需要我们探测很多次才可以找到一个空白单元格，当然这个问题也有解决办法，那就是下面说的二次探测。

#### 2. 二次探测
二次探测是为了解决线性探测时由于聚集带来的影响的一种方法，线性探测时如果存在连续的聚集单元那么寻找一个空白单元格需要多次探测，因为线性探测每次的步长是+1。比如从索引index开始，线性探测就是index+1，index+2，index+3....
如果使用二次探测，其实就是加大了每次探测的步长，如果从索引index开始，二次探测就是index+1，index+2^2,index+3^2,index+4^2...，很明显就是每次探测的步长都是线性探测步长的二次方，所以称作二次探测。

+ 优点
这样做的好处是可以一次探测较长的距离，基本可以解决连续聚集单元查询一个空白单元格时需要多次探测的问题。

+ 缺点
二次探测也有缺点，就是如果一开始连续插入的元素是2-12-22-32-42-52这种，这时候其实索引为2-3-6-11-18-27的位置上都有了元素，这其实也是一种步长不一的聚集。因为如果要插入一个新元素72的话，还是要探测多次从而影响效率，当然一开始插入2-12-22-32-42-52这种的概率要比插入连续数字的概率小一点，但是问题还是存在的。这就用到了再哈希法。

#### 3. 再哈希法？
公式：步长 = 质数 - (key % 质数)
质数必须小于数组的长度，这样就可以保证返回的结果不可能为0

## 六、哈希化的效率（链地址法效率大于开放地址法）

哈希表的特点就是可以将字母/单词转化为数字，从而在执行插入和查询操作的时候效率要高于数组。
如果插入的时候没有冲突，那么此时操作的效率是最高的；
如果有冲突，那么就取决于找多少次才可以找到一个空白单元格也就是探测的长度。

### 填装因子
无论是链地址法还是开放地址法，探测空白单元格的次数都和填装因子有关。
填装因子 = 当前哈希表中的总数据项 / 哈希表的长度

对于链地址法，填装因子可能大于1，因为链地址法可以无限的延伸下去
对于开放地址法，填装因子只能小于等于1，因为当空白位置被填满之后就无法再插入新的元素了

### 开发地址法的效率
对于线性探测来说，当填装因子变大的时候，需要探测的次数是呈现指数级上升的，这也很好理解，当空白单元格越来越少，后面要找一个空白单元格就需要多次探测；但是当给定要存放100个数据的话，当填充因子变小的话，此时就需要更大的存储空间，也就是哈希表的长度要增大。

对于二次探测和再哈希法来说，效率要比线性探测好，但是当填装因子变大的时候，查询次数也是呈现指数级上升的，效率也不高
### 链地址法的效率
对链地址法来说，假设现在我们的哈希表长度为size，每一个下标都对于一个数组，所有这些数组中存放的元素个数为N
平均起来，每一个数组中包含的元素为：N / Size，这个公式其实和填装因子的公式是一样的，就是存放的元素个数 / 哈希表长度。

对于链地址法来说，随着填装因子的增大，查询次数是线性增大的，不会随着指数级上升，所以链地址法的效率会大于开放地址法，因为它不会因为添加了某个元素之后性能急剧下降，Java中的HashMap也使用的是链地址法。

## 七、如何写一个好的哈希函数？
哈希化就是将单词转化成为数组数字下标的过程，而如何优雅的将单词转化为数字并且解决在转化的过程中出现出现的冲突，就需要我们设计一个好的哈希函数去实现。
一个好的哈希函数必须具备两个特点：
1. 快速的计算
哈希表的特点就是插入和查询元素的速度快，所以哈希函数的计算速度必须快，而在计算机中乘法和除法都是比较浪费时间的，所以我们需要尽可能的使用加减法，尽可能的少使用乘法和除法。
之前的方案是将单词中每一个字母依次进行幂的连乘，比如cats这个单词结果就是：3*27^3 + 1*27^2 + 19*27^1 + 20*27^0 = 60337
很明显这种方案如果只计算27底数的次方的话其实就是n +  n-1 +  n-2 +  ... + 1，综合起来进行了n(n+1) / 2 次乘法，进行了n次加法。

如果我们将上述这个多项式通过霍纳法则进行合并优化之后，那么如下：((3*27 + 1)*27 + 19) * 27 + 20,综合起来进行了N次乘法，N此加法。
很明显这一步将原来的时间复杂度从O(N^2)转化成了O(N)，提高了计算的速度。

2. 均匀的分步
为了尽可能的让元素的下标在数组中均匀的发布，推荐在使用常量的地方都使用质数，比如：
+ 设置哈希表的长度的时候
+ 设置N次幂的底数的时候，比如27,37等

注意：Java中的HashMap由于采用的是链地址法，所以使用的数组长度必须为2的N次幂。然后在压缩的时候采用的是位运算法，而不是取模运算。

## 基于链地址法封装哈希表
1. 属性
+ storage：存放一个个桶bucket的数组，也就是哈希表的外层数组
+ limit：当前哈希表中一共可以存放多少个桶
+ count：当前哈希表中当前存储了多少个元素

2. 说明
哈希表中的每一个index都对应一个数组，这里我们称之为桶bucket
每一个桶内部存放的是一个个的元素，这些元素都有自己的key和value，为了方便存放还是使用数组来实现，所以桶里面存放的还是一个个的数组
最后哈希表的格式就是：[[[k,v],[k,v]],[[k,v]],[[k,v],[k,v]]]

3. 增删改查方法详见JS文件