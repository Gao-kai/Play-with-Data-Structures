## 如何评价一个算法的好坏？
最简单的方法就是测试不同算法对相同输入的执行时间，但是比较考验执行环境和测试数据的稳定性。其实还有以下标准用来评估算法的好坏：
1. 程序的正确性，也就是写的算法必须是可正确执行的，这是必须条件
2. 程序的可读性，表现为代码书写规范易读
3. 程序的健壮性，意思就是对于各种边界值的考虑是否完整

除了以上三个条件之外，还有下面两个复杂度标准：
1. 时间复杂度(time complexity):指的就是估算该算法执行过程中总共需要执行多少个计算机语句才可以跑完算法
2. 空间复杂度(space complexity):指的是估算该算法执行过程中需要开辟多少内存空间的大小才可以跑完程序，比如定义变量的个数，开辟内存空间的大小等

## 评估算法复杂度
评估一个算法复杂度我们通过使用大O表示法，大O表示法表示的是数据规模为N对应的复杂度，它的特点是忽略常数、系数和低阶。

1. O(1)复杂度
```js
for(let i=0;i<10;i++){
	console.log(i);
}
// 分析:定义i变量语句1次,i<n比较10次,循环语句console执行10次，i++执行10次，所以时间复杂度总计31，使用大O表示法忽略系数和常数后为O(1)
```

2. O(n)复杂度
```js
for(let i=0;i<n;i++){
	console.log(i);
}
// 分析:定义i变量语句1次,i<n比较n次,循环语句console执行n次，i++执行n次，所以时间复杂度总计3n+1，使用大O表示法忽略系数和常数后为O(n)
```

3. O(n^2)复杂度
```js
for(let i=0;i<n;i++){
	for(let j=0;j<n;j++){
		console.log(j);
	}
}
// 分析:第一次循环为1+n+n,里面的第二次for循环执行了n次，所以总计为1+2n + n * (3n+1) = 3n^2 + 3n +1，使用大O表示法忽略系数和常数和低阶后为O(n^2)
```

4. O(logn)复杂度
注意：由于log2(8)都可以换底写成log2(9) * log9(8),所以log2(n)都可以换底写成log2(9) * log9(n)，因此前面的log2(9)就当做常数省略掉，剩下的log9(n)和log2(n)都被认定为logn的复杂度。
```js
while((n= n / 2) > 0) {
	console.log(n);
}
// 分析:使n/2之后还可以大于0，那就是求这个n可以被2整除几次，这不就是log2为底求对数么，所以总计需要执行2 * log2(n)次，使用大O表示法忽略系数和常数后为O(log2(n))
```

## 大O估算法的优先排序
从上到下代表程序执行的时间依次增加，所以应该尽可能的编写时间复杂度较低的算法才是最好的思路。
+ O(1) 常数阶
+ O(logn) 对数阶
+ O(n) 线性阶
+ O(nlogn) nlogn阶
+ O(n^2) 平方阶
+ O(n^3) 立方阶
+ O(2^n) 指数阶
+ O(n!) 阶乘

## 估算斐波那契数列不同算法实现的复杂度分析
就拿一道最常见的算法题：求斐波那契额第N的数的值来说，实现的算法不同其相同输入的执行时间复杂度也不同。
```bash
斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：
F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1
给定 n ，请计算 F(n) 。
```

### 1. 基于递归实现
当n=1的时候，等于执行f(1),执行1次
当n=2的时候，等于执行f(1) + f(0),加上第一次进来执行的1次，总共执行了2+1次
当n=3的时候，等于执行f(2) + f(1)，也就是3次+1次+第一次进来执行的1次，总共执行了4+1次
当n=4的时候，等于执行f(3) + f(2)，也就是5次+3次+第一次进来执行的1次，总共执行了8+1次
......
可以发现随着n的增大，函数执行的次数是2^n+1,用大O表示法表示为O(2^n)，是一种性能较低的算法。
```js
function fibonacci(n) {
	if (n <= 1) {
		return n;
	}
	// 执行一次+ 就等于执行一次 也可以看做fibonacci函数执行的次数
	return fibonacci(n - 2) + fibonacci(n - 1)
}
```

### 2. 基于for循环实现
for循环执行了多少次，那么就可以看做该算法的时间复杂度是多少。很明显，这个算法中的时间复杂度就是O(n)，相比于上面递归的实现这种解法性能高了很多。
```js
function fibonacci(n) {
	if (n <= 1) {
		return n;
	}
	
	let first = 0;
	let second = 1;
	let sum;
	// 计算第n位(n>=2)的斐波那契额的数，需要经过n-1次的相加才可以得到，因为它恒定的是前数 + 后数
	for (let i = 2; i <= n ; i++) {
		sum = first + second;
		first = second; // 上一次计算的第二个数是下一次相加的第一个数
		second = sum; // 上一次计算的和是下一次相加的第二个数
	}
	
	return sum;
}
```

### 3. 基于数组实现
这种实现的算法复杂度还是O(n),只是涉及到操作数组会被上面这种交换变量的方法效率稍低一点。
```js
function fibonacci(n) {
	if(n<2){
		return n;
	}

	let arr = [0,1];
	for(let i=2;i<=n;i++){
		arr[i] = arr[i-2] + arr[i-1];
	}

	return arr[n];
}
```
拿上面两种做法做比较发现，输入同样的N=30，递归解法会导致栈溢出，而循环解法只需要很短的时间就可以计算出结果，这说明对于相同的问题使用不同的算法其执行效率会大不相同，所以我们要尽量实现复杂度低的算法以提高代码的执行效率。