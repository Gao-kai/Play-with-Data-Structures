### 复杂度分析的三个维度
1. 复杂度的分析主要分为三个方面去分析：
+ 最好复杂度分析
+ 最差复杂度分析
+ 平均复杂度分析

2. 算法复杂度大O表示法的n的含义
还有一个时间复杂度分析时的O(n)中的n并不是指的是一个方法或者函数的参数是n那么这个算法的复杂度就是n，这个O(n)中的n指的是当前这个算法的数据规模，假设我们遍历一个长度为100的数组，那么此时算法的复杂度就是O(n),100就是数据规模也就是这里的n。

### 数组复杂度分析
1. 增加节点
当增加的节点index刚好是数组末尾的时候，此时数组元素都不需要位移，因此最好复杂度为O(1)
当增加的节点index刚好是数组开头0的时候，此时数组元素都需要位移，因此最坏复杂度为O(n)
当增加的节点index是数组中0-length任意一个位置的时候，平均复杂度为1+2+3+...+n / n,我们知道从1开始加到n的值是1/2 * n(n+1),最后计算得到平均复杂度的值是n+1/2。除去常数项2/1最后得到的复杂度还是O(n)。

tips：等差数列的两个公式
通项公式an = a1 + (n-1) * d(d为差额，a1就是第一个元素的值)
前n项的和Sn = An + An-1 + An-2 + ...+ 1 = n*A1 + 1/2 * n(n-1) / d
从1加到n的值是：1/2 * n(n+1)
从1加到n-1的值是：1/2 * n(n-1)

```js
/**
 * index位置后面的每一个元素都需要挪动一位，前面的不需要挪动
 * arr[i-1] 不就是arr[length-1]取到数组最后一位元素的值，然后把这个值赋值给了arr[i]，意味着最后一位向后挪了一位
 * 依次类推直到index位置停止...
 */
function add(index,element){
	let len = arr.length;
	for(let i = len;i>index;i--){
		arr[i] = arr[i - 1];
	}
	arr[index] = element;
	length++;
}
```
2. 删除节点remove
删除节点的复杂度分析同上，删除末尾节点时最好为O(1),删除首个节点时最差为O(n)，平均复杂度为O(n)
```js
function remove(index){
	let oldEl = arr[index];
	let len = arr.length;
	for(let i = index + 1;i<len;i++){
		arr[i-1] = arr[i];
	}
	// 后面每一个都向前面挪一位,全部完成之后将数组的最后一位设置为空 length-1
	arr[len - 1] = null;
	len--;
}
```

3. 查询节点get
数组访问元素的复杂度为O(1),elements[index]的时间复杂度并不会随着index的增大而增大，数组在查询元素比如在查询索引为99位置的元素的时候并不会从0开始一直查到99的位置，而是直接根据99这个索引找到存储值的内存地址，然后通过这个内存地址直接找到对应位置的元素，所以时间复杂度是常数级的O(1).

有个问题是数组是如何快速的找到index位置的内存地址的？
假设数组存储的都是整型的数字，每一个元素占4字节大小，那么由于数组内部的是连续的内存空间，内存地址是连续的。所以相邻的数组元素的内存地址一定是相差4或者4的倍数的，因此可以得出一个结论任意index位置的元素内存地址为：首元素的内存地址 + 4*index。因此数组随机访问元素的效率是很高的。

4. 设置节点的值set
同上，数组设置节点的值的复杂度也是O(1)。

### 链表复杂度分析
1. 增加节点add
链表增加节点的最好情况就是在头节点前插入，此时复杂度为O(1)
链表增加节点的最差情况就是在尾节点后插入，此时复杂度为O(n)，因为我们需要先找到要插入的节点位置这个过程就是O(n)的复杂度了
链表增加节点的平均情况经过计算其平均复杂度就是O(n)

网上说链表新增和删除节点的复杂度是O(1)指的是链表插入或者删除那一刻的复杂度，是已经假设找到了要插入的位置的前提下这句话是没错的，因为链表的插入和删除节点是不用向数组一样挪动节点位置的，而是修改下指针的指向就可以了。并且链表相比于数组最大的好处是节省内存，是用到一个内存申请一个的。
2. 删除节点remove
删除节点如上分析，最好O(1)最差O(n)

3. 查询节点get
链表查询节点的最好情况就是获取头节点，此时复杂度为O(1)
链表查询节点的最差情况就是获取尾节点，此时复杂度为O(n)
链表查询节点的平均情况经过计算其平均复杂度就是O(n)
4. 设置节点的值set
同上所诉和链表查询节点的复杂度是一样的。

### 均摊复杂度
均摊复杂度指的是经过连续多次复杂度比较低的情况后，出现个别复杂度比较高的情况，这时候我们在分析复杂度的时候就需要将较高的复杂度平均分配给前面多次复杂度低的情况，这是一种分析复杂度的方法，叫做均摊复杂度。

比如往数组的末尾连续添加元素的时候，前面的复杂度都是O(1)，只有当需要扩容的时候这一次复杂度为O(n)，将最后一次的复杂度均摊到前面n个元素上那么均摊复杂度还是O(1)。
### 复杂度震荡
拿动态数组的缩容和扩容操作来说，如果一个数组的容量是10，如果某次新增元素超出数组的容量，此时进行扩容操作，那么本次新增元素的复杂度是O(N)，并且我们设置扩容的大小为原来的2倍；反之来说如果一直删除数组中的元素，当删除的元素小于数组当前容量的一半的时候，就执行缩容操作，将容量缩小为当前容量的1/2，那么此时就会出现复杂度震荡，比如我们举个例子：

数组arr一开始申请的容量为4，当添加第5个元素的时候执行扩容操作，将容量扩大为4*2=8，这一次添加元素的复杂度为O(N)
然后紧接着又立即删除了刚才新增的这第5个元素，那么此时数组元素个数为4，是当前容量8的一半，执行缩容操作，将容量缩小为8/2=4，这一次删除元素的复杂度也是O(N)，这时候问题出来了，如果我一直先新增后删除这第5个元素的话，复杂度就会一直维持在一个较高的O(N)附近，而除此之外其他新增和删除的操作复杂度都是O(1),我们把这种复杂度一开始很低，然后突然长时间处于一个很高的现象叫做复杂度震荡。

解决复杂度震荡的方法是尽量让数组扩容的倍数和缩容时机不要相乘等于1即可，比如扩容的倍数为2倍，那么缩容的触发条件不应该是元素个数等于容量的1/2，而应该是1/3或者1/4，这样子就会避免复杂度震荡的问题。