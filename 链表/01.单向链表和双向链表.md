## 一、单向链表类LinkedList的实现
使用JS语言实现一个名为LinkedList的类，这个类上具备了实现链表元素增删改查功能的方法，比如：
+ add(index,element) 往链表的任意位置插入一个元素
+ remove(index) 将链表固定位置index处的元素移除
+ get(index) 获取链表中固定位置处的Node节点对象
+ indexOf(element) 查询某个元素是否存在于当前链表中
+ toString() 返回链表节点value的字符串表示


## 二、单向链表和数组的异同

### 相同点
链表和数组都是用来存储一系列元素的一种线性数据结构

### 不同点
1. 创建时需要的内存空间大小不同
创建数组的时候需要申请一段连续的内存空间，也就是一整块的内存，并且大小是固定的。
创建链表的时候由于链表中的元素在内存中不必是连续的内存空间，可以是分散的，这有利于充分利用计算机的内存实现灵活的内存动态管理。

2. 扩容的实现不同
当数组中要存放的元素超出申请的内存大小时候，还需要进行扩容操作，一般的做法是申请一个2倍大小的数组，然后将原数组中的元素复制过去，这会造成性能和内存空间的浪费。
在创建链表的时候不需要一开始就确定空间的大小，因为链表的大小是动态扩容的，可以无限的延伸下去。

3. 访问效率数组高于链表
数组的优点就是基于数字索引可以进行高效快速的访问到元素;
链表是无法像数组一样通过数字索引直接访问元素的，需要从头一个个的访问，直到找到对应的元素

4. 插入/删除效率链表高于数组
在数组的开头和中间插入元素的时候需要插入地方后面所有元素都位移，性能比较低;
在链表的开头和中间插入删除元素的时候是时间复杂度是O(1)，相对数组效率高很多,因为不需要元素位移只修改其next指针的引用即可。

## 三、双向链表类DoubleLinkedList的实现
## 四、单向链表和双向链表的对比
### 单向链表
1. 单向链表只能从头开始遍历或者从尾部开始遍历，一般都是从头开始遍历。
2. 单向链表代表链表是单向的，实现的原理是上一个节点中始终包含着指向下一个节点的引用指针。
3. 单向链表的优点是可以轻松的找到下一个节点，但是缺点很难基于当前节点回到上一个节点。如果我们在一个单向链表中查找当前节点的上一个节点，只有一个办法，那就是从头开始依次遍历，这很显然是非常浪费性能的。为了解决快速找到上一个节点的问题，就有了双向链表这种数据结构。

### 双向链表
1. 双向链表相对于单向链表最大的特点是双向的，这个双向指的是既可以从头遍历到尾，又可以从尾部遍历到头。
2. 双向链表的每一个节点除了value和next之外，还包含着对于上一个节点的引用prev。
3. 双向链表中一般用head指针指向头部第一个节点，用tail指针指向尾部最后一个节点。第一个节点的prev是null，最后一个节点的next是null。
4. 双向链表也有缺点，缺点就是在处理插入和删除节点操作的时候，要同时处理四个节点的引用，而不是两个。
5. 双向链表的另外一个缺点就是相比于单向链表，其占用的内存空间要大一些。

### 单向链表和双向链表的复杂度对比
双向链表最大的好处在于可以查询要新增或删除节点的时候只需要判断其index大于还是小于n/2即可，所以相比于单向链表其操作效率要高一倍，但是双向链表比单向链表多出很多内存空间。这是一个很经典的以空间换时间的方案。

### 双向链表 VS 动态数组
1. 开辟或销毁内存空间的频率而言
动态数组：开辟和销毁内存空间的次数相对较少，但是可能会造成内存空间浪费，虽然这一点可以使用缩容来解决
双向链表：开辟和销毁内存空间的次数频繁，但是不会造成内存空间的浪费，因为是用到了才开辟新的空间

2. 在那个位置操作频繁(增加/删除)
头部操作频繁：建议使用双向链表，因为动态数组在头部操作的复杂度是O(n),因为每一个节点都需要位移
尾部操作频繁：两个都可，因为复杂度都是O(1)
任意位置操作频繁：优先选择双向链表，考虑到任意位置的开头的位置

3. 访问节点
优先选择数组，因为基于数组的索引来访问数组是非常快的，原理是计算机会直接将数字索引编译为内存地址，数组直接基于内存地址访问，效率要比链表高的多。